<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Majority ‚Äî –ê–±—Å—Ç—Ä–∞–∫—Ç–Ω–∞—è —Å—Ç—Ä–∞—Ç–µ–≥–∏—è</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    background: #1a1a2e;
    font-family: 'Segoe UI', system-ui, sans-serif;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    min-height: 100vh;
    color: #eee;
    user-select: none;
  }
  h1 { font-size: 1.6rem; margin-bottom: 8px; letter-spacing: 2px; color: #e0e0ff; text-transform: uppercase; }
  .info-bar { display: flex; gap: 32px; align-items: center; margin-bottom: 12px; font-size: 1.05rem; }
  .score { display: flex; align-items: center; gap: 8px; font-weight: 600; }
  .score .dot { width: 18px; height: 18px; border-radius: 50%; display: inline-block; }
  .dot.p1 { background: #4fc3f7; box-shadow: 0 0 8px #4fc3f7aa; }
  .dot.p2 { background: #ef5350; box-shadow: 0 0 8px #ef5350aa; }
  .turn-label {
    padding: 4px 16px; border-radius: 20px; font-weight: 700;
    font-size: 0.95rem; transition: all 0.3s;
  }
  .turn-label.p1 { background: #4fc3f733; border: 2px solid #4fc3f7; color: #4fc3f7; }
  .turn-label.p2 { background: #ef535033; border: 2px solid #ef5350; color: #ef5350; }

  #board {
    display: grid; gap: 3px; padding: 12px;
    background: #16213e; border-radius: 12px;
    box-shadow: 0 0 40px #0d1117aa;
  }
  .cell {
    width: 56px; height: 56px; background: #0f3460; border-radius: 6px;
    cursor: pointer; transition: background 0.25s, transform 0.2s, box-shadow 0.3s;
    position: relative; display: flex; align-items: center; justify-content: center;
  }
  .cell:hover:not(.p1):not(.p2) { background: #1a4a7a; transform: scale(1.08); }
  .cell.p1 { background: #4fc3f7; box-shadow: 0 0 12px #4fc3f766; cursor: default; }
  .cell.p2 { background: #ef5350; box-shadow: 0 0 12px #ef535066; cursor: default; }
  .cell.last-move::after {
    content: ''; position: absolute; width: 14px; height: 14px;
    border-radius: 50%; background: rgba(255,255,255,0.35);
  }
  .cell.flip { animation: flipCell 0.35s ease; }
  @keyframes flipCell {
    0%   { transform: scale(1); }
    50%  { transform: scale(0.3) rotate(180deg); }
    100% { transform: scale(1) rotate(360deg); }
  }
  .cell.locked { pointer-events: none; }

  .controls { margin-top: 16px; display: flex; gap: 12px; flex-wrap: wrap; justify-content: center; }
  .btn {
    padding: 8px 20px; border: 2px solid #e0e0ff44; background: transparent;
    color: #e0e0ff; border-radius: 8px; cursor: pointer; font-size: 0.9rem; transition: all 0.2s;
  }
  .btn:hover { background: #e0e0ff15; border-color: #e0e0ffaa; }
  .btn.active { background: #e0e0ff22; border-color: #e0e0ff; }

  .rules {
    margin-top: 14px; max-width: 520px; text-align: center;
    font-size: 0.8rem; color: #8888aa; line-height: 1.5;
  }

  #winner-overlay {
    display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0;
    background: rgba(10,10,30,0.88); align-items: center; justify-content: center;
    flex-direction: column; z-index: 100;
  }
  #winner-overlay.show { display: flex; }
  #winner-overlay h2 { font-size: 2rem; margin-bottom: 16px; }
  #winner-overlay .btn { font-size: 1.1rem; padding: 12px 36px; }

  .thinking { opacity: 0.7; animation: pulse 0.8s infinite alternate; }
  @keyframes pulse { from { opacity: 0.5; } to { opacity: 1; } }
</style>
</head>
<body>

<h1>‚¨° Majority</h1>

<div class="info-bar">
  <div class="score"><span class="dot p1"></span> –í—ã: <span id="score1">0</span></div>
  <div class="turn-label p1" id="turnLabel">–í–∞—à —Ö–æ–¥</div>
  <div class="score"><span class="dot p2"></span> –ò–ò: <span id="score2">0</span></div>
</div>

<div id="board"></div>

<div class="controls">
  <button class="btn" onclick="initGame()">‚ü≥ –ù–æ–≤–∞—è –∏–≥—Ä–∞</button>
  <button class="btn" onclick="toggleSize()">–ü–æ–ª–µ: <span id="sizeLabel">8√ó8</span></button>
  <button class="btn" onclick="toggleDifficulty()" id="diffBtn">–ò–ò: –°—Ä–µ–¥–Ω–∏–π</button>
  <button class="btn" onclick="toggleCascade()">–ö–∞—Å–∫–∞–¥: <span id="cascLabel">–í–ö–õ</span></button>
</div>

<div class="rules">
  –°—Ç–∞–≤—å—Ç–µ —Ñ–∏—à–∫—É –Ω–∞ –ø—É—Å—Ç—É—é –∫–ª–µ—Ç–∫—É. –í—Ä–∞–∂–µ—Å–∫–∞—è –∫–ª–µ—Ç–∫–∞ <b>–∑–∞—Ö–≤–∞—Ç—ã–≤–∞–µ—Ç—Å—è</b>,
  –µ—Å–ª–∏ —Å—Ä–µ–¥–∏ –µ—ë 8 —Å–æ—Å–µ–¥–µ–π –≤–∞—à–∏—Ö —Ñ–∏—à–µ–∫ <b>—Å—Ç—Ä–æ–≥–æ –±–æ–ª—å—à–µ</b>, —á–µ–º –≤—Ä–∞–∂–µ—Å–∫–∏—Ö. –ö–∞—Å–∫–∞–¥ ‚Äî –∑–∞—Ö–≤–∞—Ç—ã –ø–æ—Ä–æ–∂–¥–∞—é—Ç –Ω–æ–≤—ã–µ.
</div>

<div id="winner-overlay">
  <h2 id="winnerText"></h2>
  <button class="btn" onclick="initGame(); document.getElementById('winner-overlay').classList.remove('show');">–ò–≥—Ä–∞—Ç—å —Å–Ω–æ–≤–∞</button>
</div>

<script>
const SIZES = [6, 8, 10];
const DIFF_NAMES = ['–õ—ë–≥–∫–∏–π', '–°—Ä–µ–¥–Ω–∏–π', '–°–∏–ª—å–Ω—ã–π'];
let sizeIdx = 1, N = 8;
let diffIdx = 1;
let board = [], currentPlayer = 1, cascadeOn = true, gameOver = false, aiThinking = false;

function toggleSize() { sizeIdx = (sizeIdx+1)%SIZES.length; N = SIZES[sizeIdx]; document.getElementById('sizeLabel').textContent = N+'√ó'+N; initGame(); }
function toggleCascade() { cascadeOn = !cascadeOn; document.getElementById('cascLabel').textContent = cascadeOn ? '–í–ö–õ' : '–í–´–ö–õ'; }
function toggleDifficulty() { diffIdx = (diffIdx+1)%3; document.getElementById('diffBtn').textContent = '–ò–ò: '+DIFF_NAMES[diffIdx]; initGame(); }

function initGame() {
  board = Array.from({length:N}, ()=>Array(N).fill(0));
  currentPlayer = 1; gameOver = false; aiThinking = false;
  renderBoard(); updateInfo();
}

function renderBoard() {
  const el = document.getElementById('board');
  el.style.gridTemplateColumns = `repeat(${N}, 56px)`;
  el.innerHTML = '';
  for (let r=0; r<N; r++) for (let c=0; c<N; c++) {
    const cell = document.createElement('div');
    cell.className = 'cell';
    cell.dataset.r = r; cell.dataset.c = c;
    cell.addEventListener('click', () => onCellClick(r,c));
    el.appendChild(cell);
  }
}

function getCell(r,c) { return document.querySelector(`.cell[data-r="${r}"][data-c="${c}"]`); }

function neighbors(r,c) {
  const dirs = [[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]];
  return dirs.map(([dr,dc])=>[r+dr,c+dc]).filter(([rr,cc])=>rr>=0&&rr<N&&cc>=0&&cc<N);
}

function countAround(b,r,c,p) { return neighbors(r,c).filter(([rr,cc])=>b[rr][cc]===p).length; }

function simulateMove(b, r, c, player) {
  const nb = b.map(row=>[...row]);
  nb[r][c] = player;
  const opp = player===1?2:1;
  let flipped = true;
  let totalFlips = 0;
  while (flipped) {
    flipped = false;
    let round = [];
    for (let rr=0;rr<N;rr++) for (let cc=0;cc<N;cc++) {
      if (nb[rr][cc]===opp) {
        if (countAround(nb,rr,cc,player) > countAround(nb,rr,cc,opp)) round.push([rr,cc]);
      }
    }
    if (round.length>0) {
      round.forEach(([fr,fc])=>{ nb[fr][fc]=player; });
      totalFlips += round.length;
      flipped = cascadeOn;
    }
  }
  return { board: nb, flips: totalFlips };
}

function applyMove(r, c, player) {
  board[r][c] = player;
  updateCellVisual(r, c, false);
  document.querySelectorAll('.last-move').forEach(el=>el.classList.remove('last-move'));
  getCell(r,c).classList.add('last-move');

  const opp = player===1?2:1;
  let allFlips = [];
  let flipped = true;
  while (flipped) {
    flipped = false;
    let round = [];
    for (let rr=0;rr<N;rr++) for (let cc=0;cc<N;cc++) {
      if (board[rr][cc]===opp) {
        if (countAround(board,rr,cc,player) > countAround(board,rr,cc,opp)) round.push([rr,cc]);
      }
    }
    if (round.length>0) {
      round.forEach(([fr,fc])=>{ board[fr][fc]=player; });
      allFlips.push(...round);
      flipped = cascadeOn;
    }
  }
  allFlips.forEach(([fr,fc],i) => {
    setTimeout(()=>updateCellVisual(fr,fc,true), i*70);
  });
  return allFlips.length;
}

function onCellClick(r,c) {
  if (gameOver || aiThinking || currentPlayer!==1 || board[r][c]!==0) return;
  const legal = getLegalCells(board, 1);
  if (!legal.some(([lr,lc]) => lr===r && lc===c)) return;
  applyMove(r,c,1);
  currentPlayer = 2;
  updateInfo();
  if (checkEnd()) return;
  aiThinking = true;
  lockBoard(true);
  const delay = Math.max(300, 50 * N);
  setTimeout(()=>{ aiMove(); }, delay);
}

function lockBoard(lock) {
  document.querySelectorAll('.cell').forEach(c => {
    if (lock) c.classList.add('locked'); else c.classList.remove('locked');
  });
}

// ===================== AI =====================

function getEmptyCells(b) {
  const cells = [];
  for (let r=0;r<N;r++) for (let c=0;c<N;c++) if (b[r][c]===0) cells.push([r,c]);
  return cells;
}

function getLegalCells(b, player) {
  const empty = getEmptyCells(b);
  const opp = player===1?2:1;
  let myCount = 0;
  for (let r=0;r<N;r++) for (let c=0;c<N;c++) if (b[r][c]===player) myCount++;
  if (myCount === 0) {
    const filtered = empty.filter(([r,c]) =>
      neighbors(r,c).every(([rr,cc]) => b[rr][cc] !== opp)
    );
    if (filtered.length > 0) return filtered;
  }
  return empty;
}

function boardScore(b, player) {
  let my=0, opp=0;
  const opponent = player===1?2:1;
  for (let r=0;r<N;r++) for (let c=0;c<N;c++) {
    if (b[r][c]===player) my++;
    else if (b[r][c]===opponent) opp++;
  }
  return my - opp;
}

function friendlyAdjacent(b, r, c, player) {
  return neighbors(r,c).filter(([rr,cc]) => b[rr][cc] === player).length;
}

function centerProximity(r, c) {
  const cr = (N-1)/2, cc = (N-1)/2;
  const maxDist = Math.sqrt(cr*cr + cc*cc);
  const dist = Math.sqrt((r-cr)*(r-cr) + (c-cc)*(c-cc));
  return 1 - dist / maxDist;
}

function neighborCount(r, c) {
  return neighbors(r,c).length;
}

function stabilityScore(b, player) {
  const opp = player===1?2:1;
  let safe = 0, risk = 0;
  for (let r=0;r<N;r++) for (let c=0;c<N;c++) {
    if (b[r][c] === player) {
      const fn = countAround(b,r,c,player);
      const en = countAround(b,r,c,opp);
      if (fn > en) safe++;
      else if (en > 0 && en >= fn) risk++;
    }
  }
  return safe - risk * 2;
}

function evaluate(b, player) {
  const opp = player===1?2:1;
  const net = boardScore(b, player);
  const myStab = stabilityScore(b, player);
  const oppStab = stabilityScore(b, opp);
  return net * 4 + (myStab - oppStab) * 1.5;
}

function aiEasy() {
  const empty = getLegalCells(board, 2);
  if (!empty.length) return null;
  let best = [], bestScore = -Infinity;
  for (const [r,c] of empty) {
    const {flips} = simulateMove(board,r,c,2);
    const score = flips * 0.5 + Math.random() * 3;
    if (score > bestScore) { bestScore = score; best = [[r,c]]; }
    else if (Math.abs(score-bestScore) < 1.5) best.push([r,c]);
  }
  return best[Math.floor(Math.random()*best.length)];
}

function aiMedium() {
  const empty = getLegalCells(board, 2);
  if (!empty.length) return null;
  let best = null, bestScore = -Infinity;

  const totalCells = N*N;
  const filled = totalCells - getEmptyCells(board).length;
  const phase = filled / totalCells;

  for (const [r,c] of empty) {
    const sim = simulateMove(board,r,c,2);
    const flips = sim.flips;
    const net = boardScore(sim.board, 2);
    const adj = friendlyAdjacent(board, r, c, 2);
    const center = centerProximity(r, c);
    const nearOpp = friendlyAdjacent(board, r, c, 1);

    let score = net * 2 + flips * 2.5;
    score += adj * (phase < 0.3 ? 4 : 2);
    score += center * (phase < 0.4 ? 3 : 1);
    score += nearOpp * 1;
    score += Math.random() * 0.5;

    if (score > bestScore) { bestScore = score; best = [r,c]; }
  }
  return best;
}

function aiHard() {
  const empty = getLegalCells(board, 2);
  if (!empty.length) return null;
  let best = null, bestVal = -Infinity;

  const totalCells = N*N;
  const filled = totalCells - getEmptyCells(board).length;
  const phase = filled / totalCells;

  for (const [r,c] of empty) {
    const sim = simulateMove(board,r,c,2);
    const myEval = evaluate(sim.board, 2);

    const emptyAfter = getEmptyCells(sim.board);
    let worstAfterReply = myEval;

    if (emptyAfter.length > 0) {
      const ranked = emptyAfter.map(([rr,cc]) => {
        const threatToUs = friendlyAdjacent(sim.board, rr, cc, 2);
        const oppCoh    = friendlyAdjacent(sim.board, rr, cc, 1);
        return { r:rr, c:cc, priority: threatToUs * 2 + oppCoh + centerProximity(rr,cc) };
      }).sort((a,b) => b.priority - a.priority);

      const sampleSize = Math.min(ranked.length, phase < 0.3 ? 15 : 25);
      const sample = ranked.slice(0, sampleSize);

      worstAfterReply = Infinity;
      for (const {r:rr, c:cc} of sample) {
        const reply = simulateMove(sim.board, rr, cc, 1);
        const sc = evaluate(reply.board, 2);
        if (sc < worstAfterReply) worstAfterReply = sc;
      }
    }

    const adj    = friendlyAdjacent(board, r, c, 2);
    const center = centerProximity(r, c);
    const nCount = neighborCount(r, c);
    const defenseBonus = nCount / 8;

    const centerW = phase < 0.4 ? 5 : 1.5;
    const cohW    = phase < 0.3 ? 4 : 1.5;

    const val = worstAfterReply * 0.6 + myEval * 0.4
              + center * centerW
              + adj * cohW
              + defenseBonus * 2
              + sim.flips * 0.5
              + Math.random() * 0.15;

    if (val > bestVal) { bestVal = val; best = [r,c]; }
  }
  return best;
}

function aiMove() {
  let move;
  if (diffIdx === 0) move = aiEasy();
  else if (diffIdx === 1) move = aiMedium();
  else move = aiHard();

  if (!move) { aiThinking = false; lockBoard(false); checkEnd(); return; }
  const [r,c] = move;
  applyMove(r,c,2);
  currentPlayer = 1;
  aiThinking = false;
  lockBoard(false);
  updateInfo();
  checkEnd();
}

// ===================== UI =====================

function updateCellVisual(r,c,animate) {
  const cell = getCell(r,c);
  const cls = board[r][c]===1?' p1':board[r][c]===2?' p2':'';
  cell.className = 'cell' + cls;
  if (cell.classList.contains('locked')) {}
  if (animate) { cell.classList.add('flip'); setTimeout(()=>cell.classList.remove('flip'),350); }
}

function updateInfo() {
  let s1=0, s2=0;
  board.forEach(row=>row.forEach(v=>{ if(v===1)s1++; if(v===2)s2++; }));
  document.getElementById('score1').textContent = s1;
  document.getElementById('score2').textContent = s2;
  const label = document.getElementById('turnLabel');
  if (aiThinking) {
    label.className = 'turn-label p2 thinking';
    label.textContent = '–ò–ò –¥—É–º–∞–µ—Ç...';
  } else {
    label.className = 'turn-label ' + (currentPlayer===1?'p1':'p2');
    label.textContent = currentPlayer===1 ? '–í–∞—à —Ö–æ–¥' : '–•–æ–¥ –ò–ò';
  }
}

function checkEnd() {
  let s1=0, s2=0, empty=0;
  board.forEach(row=>row.forEach(v=>{ if(v===1)s1++; if(v===2)s2++; if(v===0)empty++; }));

  const totalPlaced = s1 + s2;
  let ended = false;

  /* Wipeout: one side lost every piece (only after both have played) */
  if (totalPlaced >= 2 && (s1 === 0 || s2 === 0)) {
    ended = true;
  }

  /* Board full */
  if (empty === 0) {
    ended = true;
  }

  if (ended) {
    gameOver = true;
    const overlay = document.getElementById('winner-overlay');
    const txt = document.getElementById('winnerText');
    if (s1 > s2) { txt.textContent = 'üîµ –í—ã –ø–æ–±–µ–¥–∏–ª–∏! '+s1+' ‚Äî '+s2; txt.style.color='#4fc3f7'; }
    else if (s2 > s1) { txt.textContent = 'üî¥ –ò–ò –ø–æ–±–µ–¥–∏–ª! '+s2+' ‚Äî '+s1; txt.style.color='#ef5350'; }
    else { txt.textContent = 'ü§ù –ù–∏—á—å—è! '+s1+' ‚Äî '+s2; txt.style.color='#e0e0ff'; }
    overlay.classList.add('show');
    return true;
  }
  return false;
}

initGame();
</script>
</body>
</html>