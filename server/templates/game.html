<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Majority LAN ‚Äî –ò–≥—Ä–∞</title>
  <link rel="stylesheet" href="/static/app.css" />
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { 
      background: #1a1a2e; 
      font-family: 'Segoe UI', system-ui, sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      color: #eee;
      user-select: none;
      padding: 20px;
    }
    
    .game-container { 
      max-width: 1200px; 
      margin: 0 auto; 
      display: flex; 
      flex-wrap: wrap; 
      gap: 30px; 
      justify-content: center;
      align-items: flex-start;
    }
    
    #board {
      display: grid; 
      gap: 3px; 
      padding: 12px;
      background: #16213e;
      border-radius: 12px;
      box-shadow: 0 0 40px #0d1117aa;
    }
    
    .cell {
      background: #0f3460;
      border-radius: 6px;
      cursor: pointer;
      transition: background 0.25s, transform 0.2s, box-shadow 0.3s;
      position: relative;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .cell:hover:not(.p1):not(.p2):not(.p3):not(.p4):not(.p5) { 
      background: #1a4a7a; 
      transform: scale(1.08); 
    }
    
    /* Player Colors (1..5) */
    .cell.p1 { background: #4fc3f7; box-shadow: 0 0 12px #4fc3f766; cursor: default; }
    .cell.p2 { background: #ef5350; box-shadow: 0 0 12px #ef535066; cursor: default; }
    .cell.p3 { background: #10b981; box-shadow: 0 0 12px #10b98166; cursor: default; }
    .cell.p4 { background: #f59e0b; box-shadow: 0 0 12px #f59e0b66; cursor: default; }
    .cell.p5 { background: #8b5cf6; box-shadow: 0 0 12px #8b5cf666; cursor: default; }

    /* Threat indicator: glowing "!" */
    .cell.threatened::after {
      content: '!';
      position: absolute;
      font-size: 20px;
      font-weight: 900;
      color: white;
      text-shadow: 0 0 6px rgba(255,255,255,0.9), 0 0 12px rgba(255,255,255,0.4);
      pointer-events: none;
      line-height: 1;
    }

    /* Capture-preview dot */
    .cell.vulnerable::after {
      content: ''; 
      position: absolute; 
      width: 14px; 
      height: 14px;
      border-radius: 50%; 
      background: white;
      box-shadow: 0 0 6px rgba(255,255,255,0.8);
      animation: dotPulse 0.3s infinite alternate;
    }
    
    @keyframes dotPulse {
      from { transform: scale(0.7); opacity: 0.6; }
      to   { transform: scale(1.1); opacity: 1; }
    }

    .cell.flip { animation: flipCell 0.35s ease; }
    @keyframes flipCell {
      0%   { transform: scale(1); }
      50%  { transform: scale(0.3) rotate(180deg); }
      100% { transform: scale(1) rotate(360deg); }
    }
    
    .cell.locked { pointer-events: none; }

    .sidebar { 
      min-width: 280px; 
      text-align: left;
      background: #16213e;
      padding: 20px;
      border-radius: 12px;
      box-shadow: 0 0 20px #0d1117aa;
    }
    
    .player-card {
      padding: 12px; 
      margin-bottom: 10px;
      background: #0f3460; 
      border-radius: 8px; 
      border: 2px solid #1a4a7a;
      display: flex; 
      justify-content: space-between; 
      align-items: center;
      transition: all 0.3s;
    }
    
    .player-card.active { 
      border-color: #4fc3f7; 
      background: #1a4a7a; 
      transform: scale(1.03);
      box-shadow: 0 0 12px #4fc3f766;
    }
    
    .dot { 
      width: 18px; 
      height: 18px; 
      border-radius: 50%; 
      display: inline-block; 
      margin-right: 10px;
    }
    
    .dot.p1 { background: #4fc3f7; box-shadow: 0 0 8px #4fc3f7aa; }
    .dot.p2 { background: #ef5350; box-shadow: 0 0 8px #ef5350aa; }
    .dot.p3 { background: #10b981; box-shadow: 0 0 8px #10b981aa; }
    .dot.p4 { background: #f59e0b; box-shadow: 0 0 8px #f59e0baa; }
    .dot.p5 { background: #8b5cf6; box-shadow: 0 0 8px #8b5cf6aa; }
    
    .status { 
      font-size: 1.3rem; 
      margin-bottom: 20px; 
      font-weight: bold; 
      color: #e0e0ff;
      text-align: center;
      padding: 12px;
      background: #0f3460;
      border-radius: 8px;
      letter-spacing: 1px;
    }
    
    .my-turn { 
      color: #4fc3f7; 
      animation: pulse 0.8s infinite alternate;
    }
    
    @keyframes pulse { 
      from { opacity: 0.7; } 
      to { opacity: 1; } 
    }
    
    .btn {
      padding: 10px 24px;
      border: 2px solid #e0e0ff44;
      background: transparent;
      color: #e0e0ff;
      border-radius: 8px;
      cursor: pointer;
      font-size: 0.95rem;
      transition: all 0.2s;
      width: 100%;
      margin-top: 12px;
    }
    
    .btn:hover {
      background: #e0e0ff15;
      border-color: #e0e0ffaa;
    }
    
    #winner-overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(10,10,30,0.88);
      align-items: center;
      justify-content: center;
      flex-direction: column;
      z-index: 100;
    }
    
    #winner-overlay.show { display: flex; }
    #winner-overlay h2 { 
      font-size: 2.5rem; 
      margin-bottom: 20px; 
      color: #e0e0ff;
      text-shadow: 0 0 20px rgba(224, 224, 255, 0.5);
    }
    
    #winner-overlay .btn { 
      font-size: 1.1rem; 
      padding: 14px 40px;
      width: auto;
    }
  </style>
</head>
<body>

<div id="code" hidden>{{ code }}</div>

<div class="game-container">
  <div id="board"></div>

  <div class="sidebar">
    <div id="status" class="status">–ó–∞–≥—Ä—É–∑–∫–∞...</div>
    <div id="players-list"></div>
    <button class="btn" onclick="location.href='/'">–í—ã—Ö–æ–¥ –≤ –º–µ–Ω—é</button>
  </div>
</div>

<div id="winner-overlay">
  <h2 id="winner-text"></h2>
  <button class="btn" onclick="location.href='/'">–ò–≥—Ä–∞—Ç—å —Å–Ω–æ–≤–∞</button>
</div>

<script>
const code = document.getElementById('code').textContent.trim();
const myId = localStorage.getItem('mg_player_id');
let boardSize = 8;
let currentBoard = [];
let playersInfo = [];
let animationInProgress = false;
let lastBoardState = '';

async function api(path, body){
    const opts = body ? { 
      method:'POST', 
      body: JSON.stringify(body), 
      headers: {'Content-Type':'application/json'} 
    } : {};
    return fetch(path, opts).then(r=>r.json());
}

function cellSize(size) { 
  return size <= 10 ? 56 : 32; 
}

function getCell(r, c) {
  const el = document.getElementById('board');
  if (!el) return null;
  return el.querySelector(`.cell[data-r="${r}"][data-c="${c}"]`);
}

function neighbors(r, c, size) {
  const dirs = [[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]];
  return dirs.map(([dr,dc])=>[r+dr,c+dc])
    .filter(([rr,cc])=>rr>=0&&rr<size&&cc>=0&&cc<size);
}

function countAround(board, r, c, playerNum) {
  return neighbors(r, c, board.length)
    .filter(([rr,cc])=>board[rr][cc]===playerNum)
    .length;
}

function updateThreats() {
  if (!currentBoard || currentBoard.length === 0) return;
  
  const N = currentBoard.length;
  
  for (let r = 0; r < N; r++) {
    for (let c = 0; c < N; c++) {
      const cell = getCell(r, c);
      if (!cell) continue;
      
      const player = currentBoard[r][c];
      if (player === 0) {
        cell.classList.remove('threatened');
        continue;
      }
      
      const fn = countAround(currentBoard, r, c, player);
      let maxEnemyCount = 0;
      for (let p = 1; p <= 5; p++) {
        if (p !== player) {
          const en = countAround(currentBoard, r, c, p);
          maxEnemyCount = Math.max(maxEnemyCount, en);
        }
      }
      
      const hasEmpty = neighbors(r, c, N)
        .some(([rr,cc]) => currentBoard[rr][cc] === 0);
      
      const threatened = (fn - maxEnemyCount < 1) && hasEmpty;
      cell.classList.toggle('threatened', threatened);
    }
  }
}

function updateCellVisual(r, c, animate) {
  const cell = getCell(r, c);
  if (!cell) return;
  
  const val = currentBoard[r][c];
  const cls = val > 0 ? ` p${val}` : '';
  cell.className = 'cell' + cls;
  
  if (animate) {
    cell.classList.add('flip');
    setTimeout(() => cell.classList.remove('flip'), 350);
  }
}

function calculateCascadeWaves(initialBoard, moveR, moveC, player) {
  // –í—ã—á–∏—Å–ª—è–µ–º –≤–æ–ª–Ω—ã –∫–∞—Å–∫–∞–¥–∞ –∫–∞–∫ –≤ –ø—Ä–æ—Ç–æ—Ç–∏–ø–µ
  const N = initialBoard.length;
  const waves = [];
  const tmp = initialBoard.map(row => [...row]);
  
  // –ü–µ—Ä–≤—ã–π —Ö–æ–¥
  tmp[moveR][moveC] = player;
  
  let go = true;
  while (go) {
    go = false;
    const wave = [];
    
    for (let rr = 0; rr < N; rr++) {
      for (let cc = 0; cc < N; cc++) {
        const cellVal = tmp[rr][cc];
        if (cellVal !== 0 && cellVal !== player) {
          // –≠—Ç–æ –≤—Ä–∞–∂–µ—Å–∫–∞—è –∫–ª–µ—Ç–∫–∞
          const friendlyCount = countAround(tmp, rr, cc, player);
          const enemyCount = countAround(tmp, rr, cc, cellVal);
          
          if (friendlyCount > enemyCount) {
            wave.push([rr, cc]);
          }
        }
      }
    }
    
    if (wave.length > 0) {
      // –ü—Ä–∏–º–µ–Ω—è–µ–º –∑–∞—Ö–≤–∞—Ç—ã —ç—Ç–æ–π –≤–æ–ª–Ω—ã
      wave.forEach(([r, c]) => {
        tmp[r][c] = player;
      });
      waves.push(wave);
      go = true; // –ü—Ä–æ–¥–æ–ª–∂–∞–µ–º –∫–∞—Å–∫–∞–¥
    }
  }
  
  return waves;
}

function renderBoardWithAnimation(newBoard, oldBoard) {
  const N = newBoard.length;
  
  // –ù–∞–π—Ç–∏ —Ö–æ–¥ (–∫–ª–µ—Ç–∫–∞ 0 -> X)
  let moveR = -1, moveC = -1, player = 0;
  for (let r = 0; r < N; r++) {
    for (let c = 0; c < N; c++) {
      if (oldBoard[r][c] === 0 && newBoard[r][c] !== 0) {
        moveR = r;
        moveC = c;
        player = newBoard[r][c];
        break;
      }
    }
    if (moveR >= 0) break;
  }
  
  if (moveR < 0) {
    // –ù–µ—Ç —Ö–æ–¥–∞, –ø—Ä–æ—Å—Ç–æ –æ–±–Ω–æ–≤–ª—è–µ–º
    return 0;
  }
  
  // –í—ã—á–∏—Å–ª—è–µ–º –≤–æ–ª–Ω—ã –∫–∞—Å–∫–∞–¥–∞
  const waves = calculateCascadeWaves(oldBoard, moveR, moveC, player);
  
  // –£–≤–µ–ª–∏—á–µ–Ω–Ω—ã–µ –∑–∞–¥–µ—Ä–∂–∫–∏ –¥–ª—è –ª—É—á—à–µ–π –≤–∏–¥–∏–º–æ—Å—Ç–∏
  const DOT_TIME = 400;   // –í—Ä–µ–º—è –ø–æ–∫–∞–∑–∞ —Ç–æ—á–µ–∫
  const FLIP_GAP = N <= 10 ? 150 : 80;  // –ó–∞–¥–µ—Ä–∂–∫–∞ –º–µ–∂–¥—É –ø–µ—Ä–µ–≤–æ—Ä–æ—Ç–∞–º–∏
  const WAVE_PAUSE = 250; // –ü–∞—É–∑–∞ –º–µ–∂–¥—É –≤–æ–ª–Ω–∞–º–∏
  
  let t = 0;
  
  // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Ö–æ–¥
  currentBoard[moveR][moveC] = player;
  updateCellVisual(moveR, moveC, false);
  updateThreats();
  
  // –ê–Ω–∏–º–∏—Ä—É–µ–º –∫–∞–∂–¥—É—é –≤–æ–ª–Ω—É
  waves.forEach((wave, waveIdx) => {
    // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Ç–æ—á–∫–∏ –Ω–∞ –≤—Å–µ—Ö –∫–ª–µ—Ç–∫–∞—Ö –≤–æ–ª–Ω—ã
    setTimeout(() => {
      wave.forEach(([r, c]) => {
        const cell = getCell(r, c);
        if (cell) {
          cell.classList.remove('threatened');
          cell.classList.add('vulnerable');
        }
      });
    }, t);
    t += DOT_TIME;
    
    // –ü–µ—Ä–µ–≤–æ—Ä–∞—á–∏–≤–∞–µ–º –∫–ª–µ—Ç–∫–∏ –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ, –æ–¥–Ω—É –∑–∞ –¥—Ä—É–≥–æ–π
    wave.forEach(([r, c], i) => {
      setTimeout(() => {
        currentBoard[r][c] = player;
        const cell = getCell(r, c);
        if (cell) {
          cell.classList.remove('vulnerable');
        }
        updateCellVisual(r, c, true);
        updateThreats();
      }, t + i * FLIP_GAP);
    });
    
    t += wave.length * FLIP_GAP + WAVE_PAUSE;
  });
  
  return t;
}

function renderBoard(grid, size) {
    const el = document.getElementById('board');
    const sz = cellSize(size);
    
    // Only rebuild if size changed
    if(el.children.length !== size*size) {
        el.innerHTML = '';
        el.style.gridTemplateColumns = `repeat(${size}, ${sz}px)`;
        el.style.gap = size <= 10 ? '3px' : '2px';
        el.style.padding = size <= 10 ? '12px' : '8px';
        
        for(let r=0; r<size; r++){
            for(let c=0; c<size; c++){
                const d = document.createElement('div');
                d.className = 'cell';
                d.style.width = sz+'px';
                d.style.height = sz+'px';
                if (sz <= 32) d.style.fontSize = '14px';
                d.onclick = () => onCellClick(r,c);
                d.dataset.r = r;
                d.dataset.c = c;
                el.appendChild(d);
            }
        }
    }
    
    // –ü—Ä–æ–≤–µ—Ä–∏—Ç—å, –Ω—É–∂–Ω–∞ –ª–∏ –∞–Ω–∏–º–∞—Ü–∏—è
    const boardStateStr = JSON.stringify(grid);
    const oldBoard = currentBoard.length === size ? currentBoard.map(row => [...row]) : grid.map(row => [...row]);
    
    if (boardStateStr !== lastBoardState && currentBoard.length === size) {
      // –ï—Å—Ç—å –∏–∑–º–µ–Ω–µ–Ω–∏—è
      const animTime = renderBoardWithAnimation(grid, oldBoard);
      if (animTime > 0) {
        animationInProgress = true;
        setTimeout(() => {
          animationInProgress = false;
          // –§–∏–Ω–∞–ª—å–Ω–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –¥–æ—Å–∫–∏
          currentBoard = grid.map(row => [...row]);
        }, animTime);
      }
    } else {
      // –ü–µ—Ä–≤–∞—è –∑–∞–≥—Ä—É–∑–∫–∞ –∏–ª–∏ –Ω–µ—Ç –∏–∑–º–µ–Ω–µ–Ω–∏–π
      currentBoard = grid.map(row => [...row]);
      for(let r=0; r<size; r++){
        for(let c=0; c<size; c++){
          updateCellVisual(r, c, false);
        }
      }
      updateThreats();
    }
    
    lastBoardState = boardStateStr;
}

async function onCellClick(r, c) {
    if (animationInProgress) return;
    
    const res = await api(`/api/game/${code}/move`, {player_id: myId, r, c});
    if(res.ok) {
        // Lock board during animation
        document.querySelectorAll('.cell').forEach(cell => {
          cell.classList.add('locked');
        });
        
        // Quick refresh
        setTimeout(() => {
          refresh().then(() => {
            setTimeout(() => {
              document.querySelectorAll('.cell').forEach(cell => {
                cell.classList.remove('locked');
              });
            }, 500);
          });
        }, 100);
    } else {
        console.log('Move error:', res.error);
    }
}

function renderPlayers(info, scores, currentId, winner) {
    playersInfo = info;
    const box = document.getElementById('players-list');
    box.innerHTML = info.map((p, i) => {
        const pNum = i + 1;
        const isTurn = p.id === currentId;
        const isMe = p.id === myId;
        const score = scores[p.id] || 0;
        return `
            <div class="player-card ${isTurn ? 'active' : ''}">
                <div style="display:flex;align-items:center">
                    <span class="dot p${pNum}"></span>
                    <b>${p.nick}</b> ${isMe ? '(–í—ã)' : ''}
                </div>
                <div style="font-size:1.3em; font-weight:bold">${score}</div>
            </div>
        `;
    }).join('');

    const status = document.getElementById('status');
    if(winner && !animationInProgress) {
        status.textContent = "–ò–≥—Ä–∞ –æ–∫–æ–Ω—á–µ–Ω–∞!";
        status.className = "status";
        
        const wInfo = info.find(x=>x.id === winner);
        let wText = '';
        
        if (winner === 'draw') {
          wText = 'ü§ù –ù–∏—á—å—è!';
        } else if (wInfo) {
          const wNum = info.indexOf(wInfo) + 1;
          const colors = ['üîµ', 'üî¥', 'üü¢', 'üü°', 'üü£'];
          const emoji = colors[wNum - 1] || '‚≠ê';
          const score = scores[winner] || 0;
          wText = `${emoji} ${wInfo.nick} –ø–æ–±–µ–¥–∏–ª! (${score} –∫–ª–µ—Ç–æ–∫)`;
        } else {
          wText = 'üéÆ –ò–≥—Ä–∞ –æ–∫–æ–Ω—á–µ–Ω–∞!';
        }
        
        document.getElementById('winner-text').textContent = wText;
        document.getElementById('winner-overlay').classList.add('show');
    } else {
        if(currentId === myId) {
            status.textContent = "‚ö° –í–ê–® –•–û–î";
            status.className = "status my-turn";
        } else {
            const cur = info.find(x=>x.id === currentId);
            status.textContent = "–•–æ–¥–∏—Ç " + (cur ? cur.nick : "...");
            status.className = "status";
        }
    }
}

async function refresh() {
    try {
        const data = await api(`/api/game/${code}?player_id=${myId}`);
        if(data.error) {
          console.error('Game error:', data.error);
          return;
        }

        boardSize = data.size;
        renderBoard(data.board, data.size);
        
        // –ü–æ–¥–æ–∂–¥–∞—Ç—å –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –∞–Ω–∏–º–∞—Ü–∏–∏ –ø–µ—Ä–µ–¥ –ø–æ–∫–∞–∑–æ–º –ø–æ–±–µ–¥–∏—Ç–µ–ª—è
        if (data.winner && !animationInProgress) {
          setTimeout(() => {
            renderPlayers(data.players_info, data.scores, data.current_player_id, data.winner);
          }, 200);
        } else {
          renderPlayers(data.players_info, data.scores, data.current_player_id, data.winner);
        }
    } catch (e) {
        console.error('Refresh error:', e);
    }
}

setInterval(refresh, 1000);
refresh();

</script>
</body>
</html>
